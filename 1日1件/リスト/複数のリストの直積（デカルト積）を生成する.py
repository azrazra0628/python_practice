## 複数のリストの直積（デカルト積）を生成する

# Pythonで複数のリストの直積（デカルト積）を生成するにはitertools.product()を使う。

#1. 直積（デカルト積）とは
# 直積（デカルト積）は、複数の集合から要素を一つずつ取り出した組み合わせの集合。

# 2つのリストがあったとき、すべてのペアの組み合わせのリストが直積。

#2. itertools.product()の基本的な使い方

# 標準ライブラリのitertoolsモジュールをインポートして使う。
# 標準ライブラリなので追加のインストールは不要。pprintは結果を見やすくするために使う。

# 引数に2つのリストを指定するとitertools.product型のオブジェクトが返る。
# itertools.product型はジェネレータなので、それをそのままprint()しても中身は出力されない

#%%
import itertools
import pprint

l1 = ['a', 'b', 'c']
l2 = ['X', 'Y', 'Z']

p = itertools.product(l1, l2)

print(p)
# <itertools.product object at 0x1026edd80>

# forループで列挙。
# 各リストの要素の組み合わせがタプルで取得できる。
# 最後まで辿り着いたジェネレータを再度forループでまわしても何も出力されないので注意。

#%%
for x in p:
    print(x)
# ('a', 'X')
# ('a', 'Y')
# ('a', 'Z')
# ('b', 'X')
# ('b', 'Y')
# ('b', 'Z')
# ('c', 'X')
# ('c', 'Y')
# ('c', 'Z')

# タプルではなくそれぞれの要素を別々に取得することも可能。

#%%
for x,y in itertools.product(l1, l2):
    print(x,  y)
# a X
# a Y
# a Z
# b X
# b Y
# b Z
# c X
# c Y
# c Z

# 以下のような各リストをネストしたforループ（多重ループ）と同じ結果が得られていることが分かる。

#%%
for v1 in l1:
    for v2 in l2:
        print(v1, v2)
# a X
# a Y
# a Z
# b X
# b Y
# b Z
# c X
# c Y
# c Z

# list()でリスト化することも可能。タプルを要素とするリストとなる。

#%%
l_p = list(itertools.product(l1, l2))

pprint.pprint(l_p)
# [('a', 'X'),
#  ('a', 'Y'),
#  ('a', 'Z'),
#  ('b', 'X'),
#  ('b', 'Y'),
#  ('b', 'Z'),
#  ('c', 'X'),
#  ('c', 'Y'),
#  ('c', 'Z')]

# 引数を便宜上「リスト」としてきたが、
# イテラブルオブジェクトであればタプルでもリストでもrangeオブジェクトでもなんでもいい。

# また、引数にはイテラブルオブジェクトを2個以上指定できる。

#%%
t = ('one', 'two')
d = {'key1': 'value1', 'key2': 'value2'}
r = range(2)

l_p = list(itertools.product(t, d, r))

pprint.pprint(l_p)
# [('one', 'key1', 0),
#  ('one', 'key1', 1),
#  ('one', 'key2', 0),
#  ('one', 'key2', 1),
#  ('two', 'key1', 0),
#  ('two', 'key1', 1),
#  ('two', 'key2', 0),
#  ('two', 'key2', 1)]

#3. 同じリストを繰り返し使用: 引数repeat

# キーワード引数repeatに繰り返しの回数を指定すると、
# イテラブルオブジェクトを繰り返し使用して直積を生成する。

#%%
l1 = ['a', 'b']

pprint.pprint(list(itertools.product(l1, repeat=3)))
# [('a', 'a', 'a'),
#  ('a', 'a', 'b'),
#  ('a', 'b', 'a'),
#  ('a', 'b', 'b'),
#  ('b', 'a', 'a'),
#  ('b', 'a', 'b'),
#  ('b', 'b', 'a'),
#  ('b', 'b', 'b')]

# イテラブルオブジェクトを複数指定した場合は次のようになる。

#%%
l1 = ['a', 'b']
l2 = ['x', 'y']

pprint.pprint(list(itertools.product(l1, l2, repeat=2)))
# [('a', 'x', 'a', 'x'),
#  ('a', 'x', 'a', 'y'),
#  ('a', 'x', 'b', 'x'),
#  ('a', 'x', 'b', 'y'),
#  ('a', 'y', 'a', 'x'),
#  ('a', 'y', 'a', 'y'),
#  ('a', 'y', 'b', 'x'),
#  ('a', 'y', 'b', 'y'),
#  ('b', 'x', 'a', 'x'),
#  ('b', 'x', 'a', 'y'),
#  ('b', 'x', 'b', 'x'),
#  ('b', 'x', 'b', 'y'),
#  ('b', 'y', 'a', 'x'),
#  ('b', 'y', 'a', 'y'),
#  ('b', 'y', 'b', 'x'),
#  ('b', 'y', 'b', 'y')]

# l1, l1, l2, l2ではなくl1, l2, l1, l2となるので注意。


# 要素数が1000個の二重ループや100個の三重ループでの差は数十ms程度。
# 速度が重要な場合は多重ループ、
# 特に速度を重視しない場合であればitertools.product()を使ってコードの見通しをよくする、
# というように状況に応じて使い分ければOK。

# まとめ
# ①リスト内の要素をいつずつ取り出す場合には、itertoolsモジュールを使用する
# ②速度はforループのネストよりも若干遅いので、コードをすっきりさせたいときに使用するのがよい
