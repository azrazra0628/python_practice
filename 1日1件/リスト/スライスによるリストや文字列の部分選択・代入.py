## スライスによるリストや文字列の部分選択・代入

# Pythonではコロンを使って表すスライス（例: [2:5:2]）によって、
# リストや文字列、タプルなどのシーケンスオブジェクトの一部分を選択して
# 取得したり別の値を代入したりできる。

#1. スライスの基本的な使い方

# 開始位置startと終了位置stopを指定

# スライスでは選択範囲の開始位置startと終了位置stop
# を[start:stop]のように書く。

# start <= x < stopの範囲が選択される。
# start番目の値は含まれるがstop番目の値は含まれないので注意

#%%
l = [0, 10, 20, 30, 40, 50, 60]
print(l)
# [0, 10, 20, 30, 40, 50, 60]

print(l[2:5])
# [20, 30, 40]

# 開始位置startを省略した場合は最初から、
# 終了位置stopを省略した場合は最後までが選択される。
# 両方とも省略した場合はすべての値が選択される。

#%%
print(l[:3])
# [0, 10, 20]

print(l[3:])
# [30, 40, 50, 60]

print(l[:])
# [0, 10, 20, 30, 40, 50, 60]

# 範囲外を指定した場合
# 要素数を超える位置を指定してもエラーにはならず無視される。負の値を指定した場合については後述。

#%%
print(l[2:10])
# [20, 30, 40, 50, 60]

# 空のリストが返る場合
# どの要素も選択されないstartとstopを指定した場合もエラーにはならない。空のリストが返る。

#%%
print(l[5:2])
# []

print(l[2:2])
# []

print(l[10:20])
# []


# 増分stepを指定
# 開始位置startと終了位置stopに加えて、増分stepも指定可能。[start:stop:step]のように書く。

# 例えばstepを2とした場合、奇数個目の要素のみ、または偶数個目の要素のみを取得できる。

#%%
print(l[::2])
# [0, 20, 40, 60]

print(l[1::2])
# [10, 30, 50]


#2. マイナスの値で後ろから指定

# 開始位置startと終了位置stopをマイナスで指定

# 開始位置startと終了位置stopを負の値で指定すると、末尾からの位置となる。

# -1が最後の要素を示す。

# stop=-1とするとstop番目の値は含まれないため後ろから2番めの値までが選択される。

#%%
print(l[3:-1])
# [30, 40, 50]

# 増分stepをマイナスで指定
# 増分stepを負の値で指定すると、後ろから逆順で要素を取得する。

# startから逆向きに値を取得していくため、
# startのほうがstopより後ろの位置を示していないと空になってしまうので注意。

#%%
print(l[5:2:-1])
# [50, 40, 30]

print(l[2:5:-1])
# []

# startとstopを省略しstepを-1とすることで、
# もとのオブジェクトの順番を逆転したオブジェクトが取得できる。

#%%
print(l[::-1])

#3. slice関数によるスライスオブジェクトの生成

# 組み込み関数slice()を使うとスライスオブジェクトを生成できる。
# 同じ位置の要素を繰り返し取得したい場合はスライスオブジェクトを一度生成しておくだけでよいので便利。

#%%
sl = slice(2, 5, 2)
print(sl)
# slice(2, 5, 2)

print(type(sl))
# <class 'slice'>

print(l[sl])
# [20, 40]

#4. スライスによる値の代入

# スライスで選択した範囲に値を代入することが可能。

# スライスで選択した範囲の要素数と代入する要素数（右辺のオブジェクトの要素数）は
# 一致していなくてもOK。

#%%
print(l)
# [0, 10, 20, 30, 40, 50, 60]

l[2:5] = [200, 300, 400]
print(l)
# [0, 10, 200, 300, 400, 50, 60]

l[2:5] = [-2, -3]
print(l)
# [0, 10, -2, -3, 50, 60]

l[2:4] = [2000, 3000, 4000, 5000]
print(l)
# [0, 10, 2000, 3000, 4000, 5000, 50, 60]

l[2:6] = [20000]
print(l)
# [0, 10, 20000, 50, 60]

# 右辺にはリストなどのイテラブルオブジェクトのみ指定できる。
# スカラー値を指定するとエラーTypeErrorとなる。

#%%
l[2:5 ] = 200
# TypeError: can only assign an iterable

# 右辺が空だとスライスで選択した範囲の要素が削除される。

#%%
l[1:4] = []
print(l)

l[20:60] = [-1, -2, -3]
print(l)
# [0, 60, -1, -2, -3]

l[2:2] = [-100]
print(l)
# [0, 60, -100, -1, -2, -3]


#5. 二次元配列（リストのリスト）の場合

# リストのリストで構成された以下のような二次元配列にスライスを適用したい場合。

#%%
l_2d = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]
print(l_2d)
# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]

# あくまでもリストを要素としたリストなので、スライスによって選択されるのは要素であるリスト。


#%%
print(l_2d[1:3])
# [[3, 4, 5], [6, 7, 8]]

# 選択されたリストにさらにスライスを適用するにはリスト内包表記を使う。

#%%
print([l[:2] for l in l_2d[1:3]])
# [[3, 4], [6, 7]]

# 列を取得したい場合は転置する方法もある。

#%%
l_2d_t = [list(x) for x in zip(*l_2d)]
print(l_2d_t)
# [[0, 3, 6, 9], [1, 4, 7, 10], [2, 5, 8, 11]]

print(l_2d_t[1])
# [1, 4, 7, 10]

#6. 変数に代入した場合の浅いコピーと深いコピー

# スライスで取得した結果は浅いコピーとなる。

# 例えば、数値のリストの場合などは、スライスで取得した結果を変数に代入し
# その変数の要素を更新しても元のオブジェクトは変更されない。

#%%
l = [0, 10, 20, 30, 40, 50, 60]
print(l)
# [0, 10, 20, 30, 40, 50, 60]

l_slice = l[2:5]
print(l_slice)
# [20, 30, 40]

l_slice[1] = 300
print(l_slice)
# [20, 300, 40]

print(l)
# [0, 10, 20, 30, 40, 50, 60]

# 要素としてリストなどを含んでいる複合オブジェクトの場合は、
# リストの要素を更新すると元のオブジェクトも変更される。

#%%
l_2d = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]
print(l_2d)
# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]

l_2d_slice = l_2d[1:3]
print(l_2d_slice)
# [[3, 4, 5], [6, 7, 8]]

l_2d_slice[0][1] = 400
print(l_2d_slice)
# [[3, 400, 5], [6, 7, 8]]

print(l_2d)
# [[0, 1, 2], [3, 400, 5], [6, 7, 8], [9, 10, 11]]

# これを防ぐためには標準ライブラリのcopyモジュールをインポートし、deepcopy()を使う。

#%%
import copy

l_2d = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]
print(l_2d)
# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]

l_2d_slice_deepcopy = copy.deepcopy(l_2d[1:3])
print(l_2d_slice_deepcopy)
# [[3, 4, 5], [6, 7, 8]]

l_2d_slice_deepcopy[0][1] = 400
print(l_2d_slice_deepcopy)
# [[3, 400, 5], [6, 7, 8]]

print(l_2d)
# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]

#7. 文字列やタプルの場合

# これまではリスト（list型）の例を示してきたが、
# 文字列やタプルなどほかのシーケンスオブジェクトでも同様にスライスが使える。

# ただし、文字列、タプルはイミュータブル（更新不可）なので代入はできない。

#%%
s = 'abcdefg'
print(s)
# abcdefg

print(s[2:5])
# cde

print(s[::-1])
# gfedcba

s[2:5] = 'CDE'
# TypeError: 'str' object does not support item assignment

t = (0, 10, 20, 30, 40, 50, 60)
print(t)
# (0, 10, 20, 30, 40, 50, 60)

print(t[2:5])
# (20, 30, 40)

t[2:5] = (200, 300, 400)
# TypeError: 'tuple' object does not support item assignment

# まとめ
# ①リストや文字列、タプルなどのシーケンスオブジェクトで任意の要素を抽出する際にsliceを使用できる
# ②リスト以外はイミュータブルの為、代入はできない
# ③多次元リストの場合は、numpyを使用するほうが楽